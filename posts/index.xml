<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on メモ</title><link>https://kaito-aai.github.io/posts/</link><description>Recent content in Posts on メモ</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 10 Sep 2023 16:28:11 +0900</lastBuildDate><atom:link href="https://kaito-aai.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Next: routingとlayout</title><link>https://kaito-aai.github.io/posts/react/next/routing/</link><pubDate>Sun, 10 Sep 2023 16:28:11 +0900</pubDate><guid>https://kaito-aai.github.io/posts/react/next/routing/</guid><description>デフォルトのファイル配置や命名を整理していたところ、routingが効かなくなったり、layoutが存在しないと怒られたりしたので調べてみたことのメモ。
参考: https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts
NextのRouter Next.js uses a file-system based router
app(Pages Routerの場合はpages)ディレクトリ配下のディレクトリ構造がrouteになる。
ディレクトリ名、ファイル名がrouteへ反映される。
これを知って以下の疑問が出てきた。
ディレクトリ配下にページ以外のもの(ページ内で使うコンポーネントなど)を配置していると、意図しないrouteが作られたりするかもしれないからやめたほうがいい？
appまたはpagesディレクトリ配下にページ以外のものを置かないほうがよいか AppRouter, Pages Routerにより異なる。
App Routerの場合、意図しないrouteが作られるような事故は防がれる仕組みになっているので、置いてもよい。
Pages Routerの場合はそうではないので、pagesディレクトリ配下にページ以外のものを置かないほうがよい。
App Routerの場合、page.jsや、route.jsという名前のファイルに対してのみrouting可能。
(僕が実装していた際は、この規則に違反していたためroutingが効かなくなり、404エラーが出た。)
参考: https://nextjs.org/docs/app/building-your-application/routing/colocation#safe-colocation-by-default
Layout ページへレイアウトを適用するためのファイル。
App Routerの場合、appディレクトリ配下にRoot Layoutが必要。 page.jsに対応するLayout(Nesting Layouts)を個別定義することもできる。
Nesting Layoutsは、上位ディレクトリに定義されたlayout.js内部にネストする形で適用される。
以下、Root Layout, Nesting Layoutsを用意した場合のディレクトリ、ファイル配置の例
app layout.js (Root Layout) dashboard layout.js (dashboard用のNesting Layout) page.js (app/layout.jsを適用した上で、app/dashboard/layout.jsを適用) home page.js (app/layout.jsを適用) (僕が実装していた際は、Root Layoutがなく、Nesting Layoutsもなかったため、以下のエラーが出た。)</description></item><item><title>TypeScriptのenumがちょっと改善されていた</title><link>https://kaito-aai.github.io/posts/typescript/enum/</link><pubDate>Wed, 30 Aug 2023 03:11:38 +0900</pubDate><guid>https://kaito-aai.github.io/posts/typescript/enum/</guid><description>TypeScriptのEnumが型安全になっていた。
TypeScriptでEnumを使うのが良くないといわれている理由の確認中に見つけたのでメモ。
ここを使って動作確認をした。
transpile結果も確認できるので便利。
https://www.typescriptlang.org/play
エラー 以下のコードを書いてみたところtypeエラーが出た。
バージョンアップでエラーが出るように修正された？
Enumの型安全を検証するコード
enum FruitEnum { Apple = 0, Orange = 1 } const fruit: FruitEnum = 6; エラーメッセージ
Type &amp;lsquo;6&amp;rsquo; is not assignable to type &amp;lsquo;FruitEnum&amp;rsquo;.(2322)
いつからこうなった？ TypeScript 5.0で修正された。
https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html#all-enums-are-union-enums
備忘: Enum使うか、それ以外の手段を使うか 型安全になったからEnum使っても問題ないのか、それ以外の手段を使うべきなのかを調べてみた。
Enum, Const Enum, Unionをtranspile前後で比較して調査。
Enumは即時関数を使った形にtranspileされるので、Tree Shakingで使ってないコードを振り落とせないデメリットがある。
Const Enumか、Unionを使うのが良いかも。
Const EnumにはBabelでtranspileできない等のデメリットがあるらしいが未検証。
Enum transpile前
enum FruitEnum { Apple, Orange } const fruit: FruitEnum = FruitEnum.Apple; transpile後
var FruitEnum; (function (FruitEnum) { FruitEnum[FruitEnum[&amp;#34;Apple&amp;#34;] = 0] = &amp;#34;Apple&amp;#34;; FruitEnum[FruitEnum[&amp;#34;Orange&amp;#34;] = 1] = &amp;#34;Orange&amp;#34;; })(FruitEnum || (FruitEnum = {})); const fruit = FruitEnum.</description></item><item><title>Componentへパラメータを渡すとエラー</title><link>https://kaito-aai.github.io/posts/react/passobjecttocomponent/</link><pubDate>Tue, 29 Aug 2023 02:45:20 +0900</pubDate><guid>https://kaito-aai.github.io/posts/react/passobjecttocomponent/</guid><description>Componentへパラメータを渡せなかったときの原因と解決方法
エラー発生時の実装 タスクの一覧を引数にとってタスクリストを作成するコンポーネントを定義し、タスクの一覧を渡そうとしていた。 taskItems.jsx
export const TaskItems = (tasks: Task[]) =&amp;gt; { const taskElements = tasks.map(t =&amp;gt; { return &amp;lt;div className=&amp;#34;task&amp;#34; key={t.id}&amp;gt;&amp;lt;/div&amp;gt; }) return (&amp;lt;div className=&amp;#34;taskList&amp;#34;&amp;gt;{taskElements}&amp;lt;/div&amp;gt;) } home.jsx
export default function Home() { const tasks: Task[] = [ // 略 ] return ( &amp;lt;main&amp;gt; &amp;lt;TaskItems tasks={tasks}&amp;gt;&amp;lt;/TaskItems&amp;gt; &amp;lt;/main&amp;gt; ) } エラー Typeエラーが出た。
Type &amp;lsquo;{ tasks: Task[]; }&amp;rsquo; is not assignable to type &amp;lsquo;IntrinsicAttributes &amp;amp; Task[]&amp;rsquo;. Property &amp;lsquo;tasks&amp;rsquo; does not exist on type &amp;lsquo;IntrinsicAttributes &amp;amp; Task[]'.</description></item><item><title>React: i18nextで多言語対応</title><link>https://kaito-aai.github.io/posts/react/multilang-i18next/</link><pubDate>Wed, 29 Jun 2022 17:30:11 +0900</pubDate><guid>https://kaito-aai.github.io/posts/react/multilang-i18next/</guid><description>Reactで多言語対応をしたときの手順メモ
言語はブラウザに設定されたものを利用する前提
使うもの
https://www.i18next.com/ https://github.com/i18next/i18next-browser-languageDetector/tree/master i18next-browser-languagedetectorでブラウザの言語を扱えるようになる 1. インストール npm install react-i18next i18next i18next-browser-languagedetector &amp;ndash;save
2. 設定 i18n用ファイルを用意し、多言語用リソースを扱うための諸々を設定
以下のファイルを追加
i18n.ts
import i18n from &amp;#34;i18next&amp;#34;; import LanguageDetector from &amp;#39;i18next-browser-languagedetector&amp;#39;; import { initReactI18next } from &amp;#34;react-i18next&amp;#34;; const resources = { ja: { translation: { &amp;#34;Title&amp;#34;: &amp;#34;ホームページ&amp;#34;, } }, en: { translation: { &amp;#34;Title&amp;#34;: &amp;#34;Home Page&amp;#34;, } } }; i18n.use(initReactI18next) .use(LanguageDetector) .init({ // lng: &amp;#39;en&amp;#39; &amp;lt;-　LanguageDetectorが機能しないのでこの設定は削除 resources, fallbackLng: &amp;#39;en&amp;#39;, supportedLngs: [&amp;#39;en&amp;#39;, &amp;#39;ja&amp;#39;], interpolation: { escapeValue: false }, detection: { // navigatorの優先度を上げる order: [&amp;#39;navigator&amp;#39;], // デフォルトの設定だとlocalStorage, cookieにcacheするようになっている。 // ブラウザの設定を参照したいので削除 caches: [] } }) export default i18n; 3.</description></item><item><title>Widening</title><link>https://kaito-aai.github.io/posts/typescript/ts2322errorwhenstyling/</link><pubDate>Mon, 27 Jun 2022 23:58:38 +0900</pubDate><guid>https://kaito-aai.github.io/posts/typescript/ts2322errorwhenstyling/</guid><description>Widening ReactでコンポーネントをスタイリングしていたらTypescript関連のエラーがでたのでメモ。
以下のようなコードを書いた
const Component = () =&amp;gt; { const divStyle = { display: &amp;#34;flex&amp;#34;, flexDirection: &amp;#34;row&amp;#34;, }; return ( &amp;lt;div style={divStyle}&amp;gt;&amp;lt;/div&amp;gt; ); } 出てきたエラー
Type &amp;lsquo;{ display: string; flexDirection: string; }&amp;rsquo; is not assignable to type &amp;lsquo;Properties&amp;lt;string | number, string &amp;amp; {}&amp;gt;&amp;rsquo;. Types of property &amp;lsquo;flexDirection&amp;rsquo; are incompatible. Type &amp;lsquo;string&amp;rsquo; is not assignable to type &amp;lsquo;FlexDirection | undefined&amp;rsquo;.ts(2322)
FlexDirection型を設定すべきところ、&amp;ldquo;row&amp;quot;がstring型になってしまっていた (TypescriptのWideningによるもの)
const assertionでWideningを抑制して解決
以下のコードに修正
const Component = () =&amp;gt; { const divStyle = { display: &amp;#34;flex&amp;#34;, flexDirection: &amp;#34;row&amp;#34; as const, // const assertion }; return ( &amp;lt;div style={divStyle}&amp;gt;&amp;lt;/div&amp;gt; ); }</description></item><item><title>Hello</title><link>https://kaito-aai.github.io/posts/hello/</link><pubDate>Mon, 27 Jun 2022 01:05:38 +0900</pubDate><guid>https://kaito-aai.github.io/posts/hello/</guid><description>テストページ aaa
a b c abcde
interface A { prop: string; } var a: A = { prop: &amp;#34;a&amp;#34; }; alert(a);</description></item></channel></rss>